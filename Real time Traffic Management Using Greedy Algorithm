#include <iostream>
#include <vector>
#include <queue>
#include <string>
#include <algorithm> // Not strictly needed for this version but often useful
#include <limits>    // For std::numeric_limits
#include <stdexcept> // For std::runtime_error
#include <ctime>     // For time()
#include <cstdlib>   // For srand() and rand()

// --- Configuration Constants ---
const int SIMULATION_TIME_STEPS = 50; // Reduced for more readable output initially
const int MIN_GREEN_TIME = 5;         // Min time a light stays green
const int MAX_GREEN_TIME = 15;        // Max time a light stays green
const int YELLOW_TIME = 2;            // Yellow light duration
const double VEHICLE_ARRIVAL_PROBABILITY = 0.4; // Chance of new vehicle per road per step

// --- Data Structures ---
int nextVehicleId = 0;
struct Vehicle {
    int id;
    int arrivalTimeStep;
    int sourceRoadId;

    Vehicle(int time, int roadId) : id(nextVehicleId++), arrivalTimeStep(time), sourceRoadId(roadId) {}
};

struct Road {
    int id;
    std::string name;
    std::queue<Vehicle> waitingVehicles;
    int vehiclesPassedThisGreenCycle = 0; // Renamed for clarity, reset when light turns yellow

    Road(int road_id, const std::string& road_name) : id(road_id), name(road_name) {}

    void addVehicle(const Vehicle& v) {
        waitingVehicles.push(v);
    }

    bool hasVehicles() const {
        return !waitingVehicles.empty();
    }

    size_t queueLength() const {
        return waitingVehicles.size();
    }

    Vehicle processVehicle() { // currentTimeStep not needed here anymore
        if (!waitingVehicles.empty()) {
            Vehicle v = waitingVehicles.front();
            waitingVehicles.pop();
            vehiclesPassedThisGreenCycle++;
            return v;
        }
        throw std::runtime_error("Tried to process vehicle from empty queue");
    }
};
enum class LightState { GREEN, YELLOW }; // ALL_RED_TRANSITION was conceptual, not strictly needed as a state

struct Intersection {
    int id;
    std::vector<Road*> incomingRoads;
    int currentGreenRoadIndex = 0;
    LightState currentLightState = LightState::GREEN;
    int phaseTimer = 0; // Time remaining for current green/yellow phase

    Intersection(int intersection_id) : id(intersection_id) {}

    void addRoad(Road* road) {
        incomingRoads.push_back(road);
    }

    void initializeLights() {
        if (incomingRoads.empty()) return;
        currentGreenRoadIndex = 0;
        currentLightState = LightState::GREEN;
        phaseTimer = MIN_GREEN_TIME;
        std::cout << "[Time 0] Intersection " << id << ": Light for "
                  << incomingRoads[currentGreenRoadIndex]->name << " is GREEN (Duration: " << phaseTimer << ")." << std::endl;
    }

    void updateLightPhase(int currentTimeStep) {
        if (incomingRoads.empty()) return;

        phaseTimer--;

        if (phaseTimer <= 0) {
            Road* previousGreenRoad = incomingRoads[currentGreenRoadIndex];

            if (currentLightState == LightState::GREEN) {
                currentLightState = LightState::YELLOW;
                phaseTimer = YELLOW_TIME;
                previousGreenRoad->vehiclesPassedThisGreenCycle = 0; // Reset counter for this road
                std::cout << "  [Time " << currentTimeStep << "] EVENT: Light for "
                          << previousGreenRoad->name << " changed to YELLOW (Duration: " << phaseTimer << ")." << std::endl;

            } else if (currentLightState == LightState::YELLOW) {
                // GREEDY CHOICE LOGIC for next green light
                int oldGreenRoadIndex = currentGreenRoadIndex;
                int nextBestCandidateIndex = oldGreenRoadIndex; // Start with current as a fallback
                size_t maxQueueFound = 0;

                // Iterate through roads, typically preferring roads other than the current one
                // to find the longest queue. The loop structure ensures all roads are checked,
                // starting from the one after the current green, giving others a chance.
                for (size_t i = 0; i < incomingRoads.size(); ++i) {
                    int R_idx = (oldGreenRoadIndex + 1 + i) % incomingRoads.size();
                    if (incomingRoads[R_idx]->queueLength() > maxQueueFound) {
                        maxQueueFound = incomingRoads[R_idx]->queueLength();
                        nextBestCandidateIndex = R_idx;
                    }
                }
                
                std::string decisionReason;

                // Determine the actual next green road and the reason
if (maxQueueFound > 0) {
                    // A road (potentially different from oldGreenRoadIndex if it looped around)
                    // was found with the longest queue among those considered.
                    currentGreenRoadIndex = nextBestCandidateIndex;
                    decisionReason = "Greedy choice: " + incomingRoads[currentGreenRoadIndex]->name +
                                     " has longest queue (" + std::to_string(maxQueueFound) + " cars).";
                } else {
                    // No other road had a waiting queue (maxQueueFound is 0).
                    // Check if the road that was just green (oldGreenRoadIndex) still has vehicles.
                    if (incomingRoads[oldGreenRoadIndex]->hasVehicles()) {
                        currentGreenRoadIndex = oldGreenRoadIndex; // Continue with the same road
                        decisionReason = "Continuing with " + incomingRoads[currentGreenRoadIndex]->name +
                                         " (queue: " + std::to_string(incomingRoads[currentGreenRoadIndex]->queueLength()) +
                                         ", others empty).";
                    } else {
                        // All roads are empty. Cycle to the next one.
                        currentGreenRoadIndex = (oldGreenRoadIndex + 1) % incomingRoads.size();
                        decisionReason = "All roads empty, cycling to " + incomingRoads[currentGreenRoadIndex]->name + ".";
                    }
                }
                
                currentLightState = LightState::GREEN;
                size_t chosenQueueLen = incomingRoads[currentGreenRoadIndex]->queueLength();
                phaseTimer = MIN_GREEN_TIME + (chosenQueueLen / 2); // Adaptive green time
                if (phaseTimer > MAX_GREEN_TIME) phaseTimer = MAX_GREEN_TIME;
                if (phaseTimer < MIN_GREEN_TIME) phaseTimer = MIN_GREEN_TIME;

                std::cout << "  [Time " << currentTimeStep << "] EVENT: Light for "
                          << incomingRoads[currentGreenRoadIndex]->name << " changed to GREEN. "
                          << "REASON: " << decisionReason << " "
                          << "(Actual Queue: " << chosenQueueLen << ", Set Duration: " << phaseTimer << ")." << std::endl;
            }
        }
    }
};

class TrafficSimulation {
public:
    std::vector<Road> allRoads;
    std::vector<Intersection> allIntersections;
    int currentTimeStep = 0;
    long totalWaitingTime = 0;
    long totalVehiclesProcessed = 0;
    // For clearer output, let's buffer events of a step
    std::vector<std::string> stepEvents;


    void setupSingleIntersectionSystem() {
        allRoads.emplace_back(0, "Northbound");
        allRoads.emplace_back(1, "Eastbound");
        allRoads.emplace_back(2, "Southbound");
        allRoads.emplace_back(3, "Westbound");

        allIntersections.emplace_back(0);
        Intersection& mainIntersection = allIntersections[0];
        for(size_t i=0; i < allRoads.size(); ++i) {
            mainIntersection.addRoad(&allRoads[i]);
        }
        mainIntersection.initializeLights(); // Initial light status is printed here
    }
